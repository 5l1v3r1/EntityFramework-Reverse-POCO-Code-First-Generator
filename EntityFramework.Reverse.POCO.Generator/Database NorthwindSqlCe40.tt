<#@ include file="EF.Reverse.POCO.v3.ttinclude" #>
<#
    // v3.0.8
    // Please make changes to the settings below.
    // All you have to do is save this file, and the output file(s) are generated. Compiling does not regenerate the file(s).
    // A course for the v2 generator is available on Pluralsight at https://www.pluralsight.com/courses/code-first-entity-framework-legacy-databases

    // Settings ***************************************************************************************************************************
    // Only the most popular settings are listed below.
    // Either override Settings.* here, or edit the Settings, FilterSettings and SingleContextFilter classes located at the top of EF.Reverse.POCO.v3.ttinclude
    
    // For help on the various Types below, please read https://github.com/sjh37/EntityFramework-Reverse-POCO-Code-First-Generator/wiki/Common-Settings.*Types-explained
    // The following entries are the only required settings.
    Settings.DatabaseType            = DatabaseType.SqlCe; // SqlServer, SqlCe. Coming next: PostgreSQL, MySql, Oracle
    Settings.TemplateType            = TemplateType.EfCore3; // Ef6, EfCore2, EfCore3, FileBased. FileBased specify folder using Settings.TemplateFolder
    Settings.GeneratorType           = GeneratorType.EfCore; // Ef6, EfCore, Custom. Custom edit GeneratorCustom class to provide your own implementation
    Settings.UseMappingTables        = false; // Set to false for EfCore. EFCore will add support for this in v3 at some point, so please set this to false. If true, mapping will be used and no mapping tables will be generated. If false, all tables will be generated.
    Settings.FileManagerType         = FileManagerType.Custom; // .NET project = VisualStudio; .NET Core project = Custom; No output (testing only) = Null
    Settings.ConnectionString        = @"Data Source=C:\S\Source (open source)\EntityFramework Reverse POCO Code Generator\EntityFramework.Reverse.POCO.Generator\App_Data\NorthwindSqlCe40.sdf";
    Settings.ConnectionStringName    = "MyDbContextSqlCE4"; // ConnectionString key as specified in your app.config/web.config/appsettings.json
    Settings.DbContextName           = "MyDbContextSqlCE4"; // Class name for the DbContext to be generated. Note: If generating separate files, please give the db context a different name from this tt filename.
    Settings.GenerateSeparateFiles   = false;
    Settings.Namespace               = "EntityFramework_Reverse_POCO_Generator.SqlCe4"; // Override the default namespace here
    Settings.TemplateFolder          = Path.Combine(Settings.Root, "Templates"); // Only used if Settings.TemplateType = TemplateType.FileBased; Please read https://github.com/sjh37/EntityFramework-Reverse-POCO-Code-First-Generator/wiki/Custom-file-based-templates
    Settings.AddUnitTestingDbContext = true; // Will add a FakeDbContext and FakeDbSet for easy unit testing

    // Elements to generate ***************************************************************************************************************
    // Add the elements that should be generated when the template is executed.
    // Multiple projects can be used that separate the different concerns.
    Settings.ElementsToGenerate = Elements.Poco | Elements.Context | Elements.Interface | Elements.PocoConfiguration | Elements.Enum;
    
    // Filtering **************************************************************************************************************************
    // Filtering can now be done via one or more Regex's and one or more functions.
    // Gone are the days of a single do-it-all regex, you can now split them up into many smaller Regex's.
    // You can have as many as you like, and mix and match them.
    // These settings are only used by the single context filter SingleContextFilter (Settings.GenerateSingleDbContext = true)
    // For further information please visit https://github.com/sjh37/EntityFramework-Reverse-POCO-Code-First-Generator/wiki/Filtering
    // For multi-context filtering (Settings.GenerateSingleDbContext = false), please read https://github.com/sjh37/EntityFramework-Reverse-POCO-Code-First-Generator/wiki/Generating-multiple-database-contexts-in-a-single-go
    // Single-context filtering is done via FilterSettings and SingleContextFilter classes.
    // Override the filters here, or edit directly the FilterSettings and SingleContextFilter classes located at the top of EF.Reverse.POCO.v3.ttinclude
    FilterSettings.Reset();
    FilterSettings.AddDefaults();

    // Examples:
    //FilterSettings.IncludeViews                 = true;
    //FilterSettings.IncludeSynonyms              = false;
    //FilterSettings.IncludeStoredProcedures      = true;
    //FilterSettings.IncludeTableValuedFunctions  = false; // If true, for EF6 install the "EntityFramework.CodeFirstStoreFunctions" NuGet Package.
    //FilterSettings.IncludeScalarValuedFunctions = false;

    // Examples:
    //FilterSettings.SchemaFilters.Add(new RegexExcludeFilter("[Ff]inance.*")); // This excludes the Finance schema
    //FilterSettings.SchemaFilters.Add(new RegexIncludeFilter("dbo.*")); // This includes only dbo schema
    //FilterSettings.TableFilters.Add(new RegexExcludeFilter(".*[Bb]illing.*")); // This excludes all tables with 'billing' anywhere in the name
    //FilterSettings.TableFilters.Add(new RegexIncludeFilter("^[Cc]ustomer.*")); // This includes any remaining tables with names beginning with 'customer'
    FilterSettings.TableFilters.Add(new RegexExcludeFilter("AspNet.*")); // This excludes all tables starting with 'AspNet'
    FilterSettings.TableFilters.Add(new RegexExcludeFilter("__EFMigrationsHistory")); // This excludes all tables starting with 'AspNet'
    //FilterSettings.ColumnFilters.Add(new RegexExcludeFilter("[Cc]reated[Aa]t.*")); // This excludes all columns starting with 'CreatedAt' e.g CreatedAtUtc
    //FilterSettings.ColumnFilters.Add(new RegexIncludeFilter(".*")); // Rarely used as it would only include columns with names listed here

    // Other settings *********************************************************************************************************************
    Settings.CommandTimeout                         = 600; // SQL Command timeout in seconds. 600 is 10 minutes, 0 will wait indefinitely. Some databases can be slow retrieving schema information.
    Settings.DbContextInterfaceBaseClasses          = "IDisposable"; // Specify what the base classes are for your database context interface
    Settings.DbContextBaseClass                     = "DbContext"; // Specify what the base class is for your DbContext. For ASP.NET Identity use "IdentityDbContext<ApplicationUser>";
    Settings.OnConfiguration                        = OnConfiguration.ConnectionString; // EFCore only. Determines the code generated within DbContext.OnConfiguration(). Please read https://github.com/sjh37/EntityFramework-Reverse-POCO-Code-First-Generator/wiki/OnConfiguration    Settings.GenerateSeparateFiles   = false;
    Settings.AddParameterlessConstructorToDbContext = true; // EF6 only. If true, then DbContext will have a default (parameter-less) constructor which automatically passes in the connection string name, if false then no parameter-less constructor will be created.
    Settings.ConfigurationClassName                 = "Configuration"; // Configuration, Mapping, Map, etc. This is appended to the Poco class name to configure the mappings.
    Settings.DatabaseReaderPlugin                   = ""; // Eg, "c:\\Path\\YourDatabaseReader.dll,Full.Name.Of.Class.Including.Namespace". See #501. This will allow you to specify a pluggable provider for reading your database.

    Settings.EntityClassesModifiers        = "public"; // "public partial";
    Settings.ConfigurationClassesModifiers = "public"; // "public partial";
    Settings.DbContextClassModifiers       = "public"; // "public partial";
    Settings.DbContextInterfaceModifiers   = "public"; // "public partial";
    Settings.ResultClassModifiers          = "public"; // "public partial";

    Settings.UsePascalCase                            = true; // This will rename the generated C# tables & properties to use PascalCase. If false table & property names will be left alone.
    Settings.UsePropertyInitialisers                  = false; // Removes POCO constructor and instead uses C# 6 property initialisers to set defaults
    Settings.UseLazyLoading                           = true; // Marks all navigation properties as virtual or not, to support or disable EF Lazy Loading feature
    Settings.UseInheritedBaseInterfaceFunctions       = false; // If true, the main DBContext interface functions will come from the DBContextInterfaceBaseClasses and not generated. If false, the functions will be generated.
    Settings.IncludeComments                          = CommentsStyle.AtEndOfField; // Adds comments to the generated code
    Settings.IncludeExtendedPropertyComments          = CommentsStyle.InSummaryBlock; // Adds extended properties as comments to the generated code
    Settings.IncludeConnectionSettingComments         = true; // Add comments describing connection settings used to generate file
    Settings.DisableGeographyTypes                    = false; // Turns off use of System.Data.Entity.Spatial.DbGeography and System.Data.Entity.Spatial.DbGeometry as OData doesn't support entities with geometry/geography types.
    Settings.CollectionInterfaceType                  = "ICollection"; //  = "System.Collections.Generic.List"; // Determines the declaration type of collections for the Navigation Properties. ICollection is used if not set.
    Settings.CollectionType                           = "List"; // Determines the type of collection for the Navigation Properties. "ObservableCollection" for example. Add "System.Collections.ObjectModel" to AdditionalNamespaces if setting the CollectionType = "ObservableCollection".
    Settings.NullableShortHand                        = true; // true => T?, false => Nullable<T>
    Settings.AddIDbContextFactory                     = true; // Will add a default IDbContextFactory<DbContextName> implementation for easy dependency injection
    Settings.IncludeQueryTraceOn9481Flag              = false; // If SqlServer 2014 appears frozen / take a long time when this file is saved, try setting this to true (you will also need elevated privileges).
    Settings.IncludeCodeGeneratedAttribute            = false; // If true, will include the GeneratedCode attribute, false to remove it.
    Settings.UsePrivateSetterForComputedColumns       = true; // If the columns is computed, use a private setter.
    Settings.AdditionalNamespaces                     = new []{ "" }; // To include extra namespaces, include them here. i.e. "Microsoft.AspNet.Identity.EntityFramework"
    Settings.AdditionalContextInterfaceItems          = new []{ "" }; //  example: "void SetAutoDetectChangesEnabled(bool flag);"
    Settings.FileExtension                            = ".cs";

    // Code suppression (useful for non C# file generation) *******************************************************************************
    Settings.UseRegions   = true; // If false, suppresses the use of #region
    Settings.UseNamespace = true; // If false, suppresses the writing of a namespace
    Settings.UsePragma    = true; // If false, suppresses the writing of #pragma

    // Enumerations ***********************************************************************************************************************
    // Create enumerations from database tables
    // List the enumeration tables you want read and generated for
    Settings.Enumerations = new List<EnumerationSettings>
    {
        new EnumerationSettings
        {
            Name       = "CategoryName",   // Enum to generate. e.g. "DaysOfWeek" would result in "public enum DaysOfWeek {...}"
            Table      = "Categories",     // Database table containing enum values. e.g. "DaysOfWeek"
            NameField  = "[Category Name]",   // Column containing the name for the enum. e.g. "TypeName"
            ValueField = "[Category ID]"      // Column containing the values for the enum. e.g. "TypeId"
        }
    };

    // StoredProcedure return types *******************************************************************************************************
    // Override generation of return models for stored procedures that return entities.
    // If a stored procedure returns an entity, add it to the list below.
    // This will suppress the generation of the return model, and instead return the entity.
    // Example:                                 Proc name      Return this entity type instead
    // Settings.StoredProcedureReturnTypes.Add("SalesByYear", "SummaryOfSalesByYear");

    // Additional attributes on on reverse navigation and foreign key properties **********************************************************
    // If you need to serialise your entities with the JsonSerializer from Newtonsoft, this would serialise
    // all properties including the Reverse Navigation and Foreign Keys. The simplest way to exclude them is
    // to use the data annotation [JsonIgnore] on reverse navigation and foreign keys.
    // For more control, take a look at ForeignKeyAnnotationsProcessing() further down
    Settings.AdditionalReverseNavigationsDataAnnotations = new string[]
    {
        // "JsonIgnore" // Also add "Newtonsoft.Json" to the AdditionalNamespaces array above
    };

    Settings.AdditionalForeignKeysDataAnnotations = new string[]
    {
        // "JsonIgnore" // Also add "Newtonsoft.Json" to the AdditionalNamespaces array above
    };

    // Reference other namespaces *********************************************************************************************************
    // Use these namespaces to specify where the different elements now live. These may even be in different assemblies.
    // NOTE: These are only used if ElementsToGenerate is not set to generate everything.
    // Please note this does not create the files in these locations, it only adds a using statement to say where they are.
    // The way to do this is to add the "EntityFramework Reverse POCO Code First Generator" into each of these folders.
    // Then set the .tt to only generate the relevant section you need by setting
    //      ElementsToGenerate = Elements.Poco; in your Entity folder,
    //      ElementsToGenerate = Elements.Context | Elements.Interface; in your Context folder,
    //      ElementsToGenerate = Elements.PocoConfiguration; in your Configuration folder.
    // You also need to set the following to the namespace where they now live:
    Settings.PocoNamespace              = ""; // "YourProject.Entities";
    Settings.ContextNamespace           = ""; // "YourProject.Context";
    Settings.InterfaceNamespace         = ""; // "YourProject.Context";
    Settings.PocoConfigurationNamespace = ""; // "YourProject.Configuration";

    // Schema *****************************************************************************************************************************
    // If there are multiple schemas, then the table name is prefixed with the schema, except for dbo.
    // Ie. dbo.hello will be Hello.
    //     abc.hello will be AbcHello.
    Settings.PrependSchemaName = true; // Control if the schema name is prepended to the table name

    // Table Suffix ***********************************************************************************************************************
    // Appends the suffix to the generated classes names
    // Ie. If TableSuffix is "Dto" then Order will be OrderDto
    //     If TableSuffix is "Entity" then Order will be OrderEntity
    Settings.TableSuffix = null;

    // Call-backs *************************************************************************************************************************

    // AddRelationship is a helper function that creates ForeignKey objects and adds them to the foreignKeys list
    Settings.AddExtraForeignKeys = delegate(IDbContextFilter filter, Generator gen, List<ForeignKey> foreignKeys, Tables tablesAndViews) 
    {
        // Northwind example:
            
        // [Orders] (Table) to [Invoices] (View) is one-to-many using Orders.OrderID = Invoices.OrderID
        // gen.AddRelationship(filter, foreignKeys, tablesAndViews, "orders_to_invoices", "dbo", "Orders", "OrderID", "dbo", "Invoices", "OrderID", null, null, true);
            
        // [Orders] (Table) to [Orders Qry] (View) is one-to-zeroOrOne ( [Orders].OrderID = [Orders Qry].OrderID )
        // gen.AddRelationship(filter, foreignKeys, tablesAndViews, "orders_to_ordersQry", "dbo", "Orders", "OrderID", "dbo", "Orders Qry", "OrderID", "ParentFkName", "ChildFkName", true);
            
        // [Order Details] (Table) to [Invoices] (View) is one-to-zeroOrOne - but uses a composite-key: ( [Order Details].OrderID,ProductID = [Invoices].OrderID,ProductID )
        // gen.AddRelationship(filter, foreignKeys, tablesAndViews, "orderDetails_to_invoices", "dbo", "Order Details", new[] { "OrderID", "ProductID" }, "dbo", "Invoices", new[] { "OrderID", "ProductID" }, null, null, true);
    };

    Settings.ForeignKeyName = delegate(string tableName, ForeignKey foreignKey, string foreignKeyName, Relationship relationship, short attempt)
    {
        string fkName;

        // 5 Attempts to correctly name the foreign key
        switch (attempt)
        {
            case 1:
                // Try without appending foreign key name
                fkName = tableName;
                break;

            case 2:
                // Only called if foreign key name ends with "id"
                // Use foreign key name without "id" at end of string
                fkName = foreignKeyName.Remove(foreignKeyName.Length - 2, 2);
                break;

            case 3:
                // Use foreign key name only
                fkName = foreignKeyName;
                break;

            case 4:
                // Use table name and foreign key name
                fkName = tableName + "_" + foreignKeyName;
                break;

            case 5:
                // Used in for loop 1 to 99 to append a number to the end
                fkName = tableName;
                break;

            default:
                // Give up
                fkName = tableName;
                break;
        }

        // Apply custom foreign key renaming rules. Can be useful in applying pluralization.
        // For example:
        /*if (tableName == "Employee" && foreignKey.FkColumn == "ReportsTo")
            return "Manager";

        if (tableName == "Territories" && foreignKey.FkTableName == "EmployeeTerritories")
            return "Locations";

        if (tableName == "Employee" && foreignKey.FkTableName == "Orders" && foreignKey.FkColumn == "EmployeeID")
            return "ContactPerson";
        */

        // FK_TableName_FromThisToParentRelationshipName_FromParentToThisChildsRelationshipName
        // (e.g. FK_CustomerAddress_Customer_Addresses will extract navigation properties "address.Customer" and "customer.Addresses")
        // Feel free to use and change the following
        /*if (foreignKey.ConstraintName.StartsWith("FK_") && foreignKey.ConstraintName.Count(x => x == '_') == 3)
        {
            var parts = foreignKey.ConstraintName.Split('_');
            if (!string.IsNullOrWhiteSpace(parts[2]) && !string.IsNullOrWhiteSpace(parts[3]) && parts[1] == foreignKey.FkTableName)
            {
                if (relationship == Relationship.OneToMany)
                    fkName = parts[3];
                else if (relationship == Relationship.ManyToOne)
                    fkName = parts[2];
            }
        }*/

        return fkName;
    };

    // This foreign key filter used in addition to SingleContextFilter.ForeignKeyFilter()
    // Return null to exclude this foreign key
    Settings.ForeignKeyFilterFunc = delegate(ForeignKey fk)
    {
        // Example, to exclude all foreign keys for the Categories table, use:
        //if (fk.PkTableName == "Categories")
        //    return null;

        // Example, to exclude reverse navigation properties for tables ending with Type, use:
        //if (fk.PkTableName.EndsWith("Type"))
        //    fk.IncludeReverseNavigation = false;

        // You can also change the access modifier of the foreign-key's navigation property:
        //if(fk.PkTableName == "Categories")
        //     fk.AccessModifier = "internal";

        return fk;
    };

    // Generate multiple db contexts in a single go ***************************************************************************************
    // Generating multiple contexts at a time requires you specifying which tables, and columns to generate for each context.
    // As this generator can now generate multiple db contexts in a single go, filtering is done a per db context, and no longer global.
    // If GenerateSingleDbContext = true (default), please modify SingleContextFilter, this is where your previous global settings should go.
    // If GenerateSingleDbContext = false, this will generate multiple db contexts. Please read https://github.com/sjh37/EntityFramework-Reverse-POCO-Code-First-Generator/wiki/Generating-multiple-database-contexts-in-a-single-go
    Settings.GenerateSingleDbContext              = true; // Set this to false to generate multiple db contexts.
    Settings.MultiContextSettingsConnectionString = ""; // Leave empty to read data from same database in ConnectionString above. If settings are in another database, specify the connection string here.
    Settings.MultiContextSettingsPlugin           = ""; // Only used for unit testing Generator project as you can't (yet) inherit from IMultiContextSettingsPlugin. "c:\\Path\\YourMultiDbSettingsReader.dll,Full.Name.Of.Class.Including.Namespace". This will allow you to specify a pluggable provider for reading your MultiContext settings.
    Settings.MultiContextAttributeDelimiter       = '~'; // The delimiter used for splitting MultiContext attributes


    // Don't forget to take a look at SingleContextFilter and FilterSettings classes!
    // That's it, nothing else to configure ***********************************************************************************************

    FilterSettings.CheckSettings();
    Inflector.PluralisationService = new EnglishPluralizationService();
    var outer = (GeneratedTextTransformation) this;
    var fileManagement = new FileManagementService(outer);
    var generator = GeneratorFactory.Create(fileManagement, FileManagerFactory.GetFileManagerType());
    if (generator.InitialisationOk)
    {
        generator.ReadDatabase();
        generator.GenerateCode();
    }
    fileManagement.Process(true);#>
